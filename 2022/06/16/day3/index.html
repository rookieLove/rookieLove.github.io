<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>我的实习</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="title:相关知识关系型数据库架构逻辑语物理设计模式关系型数据库的设计逻辑分为三层  external schema: 表示呈现给用户的外部定义，也即对用户来说可见的操作   conceptual schema: 表示对外呈现的概念性数据定义，用户可以修改概念定义通过SQL实现数据访问需求   physical schema: 表示物理数据定义，也即实际数据分别存放的位置  关系型数据库SQL">
<meta property="og:type" content="article">
<meta property="og:title" content="我的实习">
<meta property="og:url" content="http://example.com/2022/06/16/day3/index.html">
<meta property="og:site_name" content="我的实习">
<meta property="og:description" content="title:相关知识关系型数据库架构逻辑语物理设计模式关系型数据库的设计逻辑分为三层  external schema: 表示呈现给用户的外部定义，也即对用户来说可见的操作   conceptual schema: 表示对外呈现的概念性数据定义，用户可以修改概念定义通过SQL实现数据访问需求   physical schema: 表示物理数据定义，也即实际数据分别存放的位置  关系型数据库SQL">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/Myblog/source/_posts/day3/3iscgyhlff.png">
<meta property="og:image" content="d:/Myblog/source/_posts/day3/gbldzafq1p.png">
<meta property="og:image" content="c:/Users/24738/Desktop/xwshwqgnmz.png">
<meta property="og:image" content="c:/Users/24738/Desktop/Begin执行流程.png">
<meta property="og:image" content="c:/Users/24738/Desktop/zfv2me1k5p.png">
<meta property="og:image" content="c:/Users/24738/Desktop/CSN原理.png">
<meta property="og:image" content="c:/Users/24738/Desktop/可见性判断.png">
<meta property="og:image" content="c:/Users/24738/Desktop/dywkc1ujse.png">
<meta property="og:image" content="c:/Users/24738/Desktop/xrxn3dbdgn.png">
<meta property="og:image" content="c:/Users/24738/Desktop/事务提交.png">
<meta property="article:published_time" content="2022-06-16T00:47:14.553Z">
<meta property="article:modified_time" content="2022-06-17T07:14:31.615Z">
<meta property="article:author" content="Rookie Dai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/Myblog/source/_posts/day3/3iscgyhlff.png">
  
    <link rel="alternate" href="/atom.xml" title="我的实习" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的实习</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-day3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/16/day3/" class="article-date">
  <time class="dt-published" datetime="2022-06-16T00:47:14.553Z" itemprop="datePublished">2022-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="title-相关知识"><a href="#title-相关知识" class="headerlink" title="title:相关知识"></a>title:相关知识</h2><h2 id="关系型数据库架构"><a href="#关系型数据库架构" class="headerlink" title="关系型数据库架构"></a>关系型数据库架构</h2><h3 id="逻辑语物理设计模式"><a href="#逻辑语物理设计模式" class="headerlink" title="逻辑语物理设计模式"></a>逻辑语物理设计模式</h3><p>关系型数据库的设计逻辑分为三层</p>
<ol>
<li>external schema: 表示呈现给用户的外部定义，也即对用户来说可见的操作  </li>
<li>conceptual schema: 表示对外呈现的概念性数据定义，用户可以修改概念定义通过SQL实现数据访问需求  </li>
<li>physical schema: 表示物理数据定义，也即实际数据分别存放的位置</li>
</ol>
<h3 id="关系型数据库SQL处理流程"><a href="#关系型数据库SQL处理流程" class="headerlink" title="关系型数据库SQL处理流程"></a>关系型数据库SQL处理流程</h3><img src="D:\Myblog\source\_posts\day3\3iscgyhlff.png" alt="图片替换文本" width="945" height="215" align="bottom"/>
| 构成元件 | 输入 | 输出 | 函数 |
| -------- | ---- | ----- | ---- |
| Parser(解析器) | parse tree | parse tree | 
| Optimizer(优化器) | parse tree | plan | 根据解析树表达的逻辑性访问需求生成执行计划 |
| Runtime | Plan | result | 运行执行计划获得期待的访问结果 |
| Buffer pool | N/A | N/A | 内存中缓冲数据的管理 |
| Storage | Page write request   Page read request| Write result   Page content| 持久化的数据存储 |						
| Catalog | N/A | N/A | 保存表定义，表统计信息，用户权限定义等 |

<h4 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h4><p><code>select * from t where c1 = 1000;</code></p>



<img src="D:\Myblog\source\_posts\day3\gbldzafq1p.png" alt="图片替换文本" width="1017" height="527" align="bottom"/>

<h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><p>Rewrite重写负责的任务包括：<br>1). 检查解析树合法性<br>2). 根据元数据扩展补充解析树<br>3). 规则性等价改写解析树(优化)</p>
<h4 id="Optimizer"><a href="#Optimizer" class="headerlink" title="Optimizer"></a>Optimizer</h4><p>优化器是一个复杂并精巧的模块，它负责的任务仅一项：<br>将<strong>解析树</strong>表达的访问请求转换成<strong>执行计划（Query Plan）</strong>。<br>该执行计划可直接被<strong>Runtime</strong>运行（类似照方抓药，Runtime不再考虑药用来解决什么问题），<br>优化体现在，生成的执行计划是在有限时间内优化器考察的所有可能执行计划中<strong>最优</strong>的。</p>
<p><code>SELECT c1, c2 from T where c1 = 10;</code></p>
<h2 id="MoGDB的事务机制"><a href="#MoGDB的事务机制" class="headerlink" title="MoGDB的事务机制"></a>MoGDB的事务机制</h2><h3 id="基础特性："><a href="#基础特性：" class="headerlink" title="基础特性："></a>基础特性：</h3><p>事务是数据库操作的执行单位，需要满足最基本的ACID（原子性、一致性、隔离性、持久性）属性。<br>（1） 原子性：一个事务提交之后要么全部执行，要么全部不执行。（<br>（2） 一致性：事务的执行不能破坏数据库的完整性和一致性。<br>（3） 隔离性：事务的隔离性是指在并发中，一个事务的执行不能被其他事务干扰。<br>（4） 持久性：一旦事务完成提交，那么它对数据库的状态变更就会永久保存在数据库中。</p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><img src="C:\Users\24738\Desktop\xwshwqgnmz.png" alt="图片替换文本" width="1017" height="527" align="bottom"/>
- 事务管理器：事务系统的**中枢**，它的实现是一个**有限循环状态机**，通过接受外部系统的命令并根据当前事务所处的状态决定事务的下一步执行过程。
- 日志管理器：用来记录事务执行的状态以及数据变化的过程，包括*事务提交日志(CLOG)*、*事务提交序列日志（CSNLOG）*以及*事务日志（XLOG）*。
    其中CLOG日志只用来记录事务执行的结果状态，CSNLOG记录日志提交的顺序，用于可见性判断；XLOG是数据的redo日志，用于恢复及持久化。
- 线程管理机制：通过一片内存区域记录所有线程的事务信息，任何一个线程可以通过访问该区域获取其他事务的状态信息。
- MVCC机制：事务执行读流程结合各事务**提交序列号（CSN）**，采用了**多版本并发控制机制（MVCC）**，实现了元组的读和写互不阻塞。
- 锁管理器：实现系统的写并发控制，通过锁机制来保证事务写流程的隔离性。

<h3 id="MogDB事务系统"><a href="#MogDB事务系统" class="headerlink" title="MogDB事务系统"></a>MogDB事务系统</h3><p>分为上层（事务块TBlockState）、中层（TransactionCommand）以及底层（TransState）三个层次。</p>
<ul>
<li>上层：主要由用户控制，对<strong>用户可见</strong>。这一层的事务，主要由用户来决定事务的发起与结束。事务生命周期由用户控制，是<strong>high-level</strong>的。<br>当用户发起：BEGIN, COMMIT, ROLLBACK, SAVEPOINT, ROLLBACK TO 或 RELEASE等命令时，会将这些调用重新转发到顶层对应的方法中：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BeginTransactionBlock  </span><br><span class="line"></span><br><span class="line">EndTransactionBlock  </span><br><span class="line"></span><br><span class="line">UserAbortTransactionBlock  </span><br><span class="line"></span><br><span class="line">DefineSavepoint  </span><br><span class="line"></span><br><span class="line">RollbackToSavepoint  </span><br><span class="line"></span><br><span class="line">ReleaseSavepoint  </span><br></pre></td></tr></table></figure>

<ul>
<li>中层：语句级别的。对用户不可见，也就是说<em>用户无法控制具体生命周期</em>。这一层的处理是跟语句相对应的。<br>由postgres.c处理，对应方法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">StartTransactionCommand  </span><br><span class="line"></span><br><span class="line">CommitTransactionCommand  </span><br><span class="line"></span><br><span class="line">AbortCurrentTransaction  </span><br></pre></td></tr></table></figure>

<ul>
<li>底层：这是最低层的事务<strong>原子性</strong>的实现，是<strong>row-level</strong>级别的。是真正意义上的事务实现，以及嵌套事务处理等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StartTransaction  </span><br><span class="line"></span><br><span class="line">CommitTransaction  </span><br><span class="line"></span><br><span class="line">AbortTransaction  </span><br><span class="line"></span><br><span class="line">CleanupTransaction  </span><br><span class="line"></span><br><span class="line">StartSubTransaction  </span><br><span class="line"></span><br><span class="line">CommitSubTransaction  </span><br><span class="line"></span><br><span class="line">AbortSubTransaction  </span><br><span class="line"></span><br><span class="line">CleanupSubTransaction  </span><br></pre></td></tr></table></figure>

<ul>
<li>例子说明：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN    </span><br><span class="line">SELECT * FROM foo    </span><br><span class="line">INSERT INTO foo VALUES(...)    </span><br><span class="line">COMMIT; </span><br></pre></td></tr></table></figure>

<img src="C:\Users\24738\Desktop\Begin执行流程.png" alt="图片替换文本" width="1017" height="527" align="bottom"/>


<pre><code>对应调用：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	 /  StartTransactionCommand;</span><br><span class="line">	/       StartTransaction;</span><br><span class="line">1) &lt;        ProcessUtility;             &lt;&lt; BEGIN</span><br><span class="line">	\       BeginTransactionBlock;</span><br><span class="line">	 \  CommitTransactionCommand;</span><br><span class="line">	/   StartTransactionCommand;</span><br><span class="line">2) /        ProcessQuery;               &lt;&lt; SELECT ...</span><br><span class="line">   \        CommitTransactionCommand;</span><br><span class="line">	\       CommandCounterIncrement;</span><br><span class="line">	/   StartTransactionCommand;</span><br><span class="line">3) /        ProcessQuery;               &lt;&lt; INSERT ...</span><br><span class="line">   \        CommitTransactionCommand;</span><br><span class="line">	\       CommandCounterIncrement;</span><br><span class="line">	 /  StartTransactionCommand;</span><br><span class="line">	/   	ProcessUtility;                 &lt;&lt; COMMIT</span><br><span class="line">4) &lt;        EndTransactionBlock;</span><br><span class="line">	\   CommitTransactionCommand;</span><br><span class="line">	 \      CommitTransaction;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>事务块状态</li>
</ul>
<p>&#x2F;&#x2F; transaction block states - transaction state of client queries<br>&#x2F;&#x2F; Note: the subtransaction states are used only for non-topmost<br>&#x2F;&#x2F; transactions; the others appear only in the topmost transaction.  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef enum TBlockState &#123;  </span><br><span class="line">	/* not-in-transaction-block states */  </span><br><span class="line">	TBLOCK_DEFAULT, /* idle */  </span><br><span class="line">	TBLOCK_STARTED, /* running single-query transaction */  </span><br><span class="line">	/* transaction block states */  </span><br><span class="line">	TBLOCK_BEGIN,         /* starting transaction block */  </span><br><span class="line">	TBLOCK_INPROGRESS,    /* live transaction */  </span><br><span class="line">	TBLOCK_END,           /* COMMIT received */  </span><br><span class="line">	TBLOCK_ABORT,         /* failed xact, awaiting ROLLBACK */  </span><br><span class="line">	TBLOCK_ABORT_END,     /* failed xact, ROLLBACK received */  </span><br><span class="line">	TBLOCK_ABORT_PENDING, /* live xact, ROLLBACK received */  </span><br><span class="line">	TBLOCK_PREPARE,       /* live xact, PREPARE received */  </span><br><span class="line">	TBLOCK_UNDO,          /* Need rollback to be executed for this topxact */  </span><br><span class="line">	/* subtransaction states */  </span><br><span class="line">	TBLOCK_SUBBEGIN,         /* starting a subtransaction */  </span><br><span class="line">	TBLOCK_SUBINPROGRESS,    /* live subtransaction */  </span><br><span class="line">	TBLOCK_SUBRELEASE,       /* RELEASE received */  </span><br><span class="line">	TBLOCK_SUBCOMMIT,        /* COMMIT received while TBLOCK_SUBINPROGRESS */  </span><br><span class="line">	TBLOCK_SUBABORT,         /* failed subxact, awaiting ROLLBACK */  </span><br><span class="line">	TBLOCK_SUBABORT_END,     /* failed subxact, ROLLBACK received */  </span><br><span class="line">	TBLOCK_SUBABORT_PENDING, /* live subxact, ROLLBACK received */  </span><br><span class="line">	TBLOCK_SUBRESTART,       /* live subxact, ROLLBACK TO received */  </span><br><span class="line">	TBLOCK_SUBABORT_RESTART, /* failed subxact, ROLLBACK TO received */  </span><br><span class="line">	TBLOCK_SUBUNDO           /* Need rollback to be executed for this subxact */  </span><br><span class="line">&#125; TBlockState;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="C:\Users\24738\Desktop\zfv2me1k5p.png" alt="图片替换文本" width="1017" height="527" align="bottom"/>

<ul>
<li>事务状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> transaction states - transaction state from server perspective</span><br><span class="line"></span><br><span class="line">typedef enum TransState &#123;</span><br><span class="line">	TRANS_DEFAULT,    /* idle */  </span><br><span class="line">	TRANS_START,      /* transaction starting */  </span><br><span class="line">	TRANS_INPROGRESS, /* inside a valid transaction */  </span><br><span class="line">	TRANS_COMMIT,     /* commit in progress */  </span><br><span class="line">	TRANS_ABORT,      /* abort in progress */  </span><br><span class="line">	TRANS_PREPARE,     /* prepare in progress */  </span><br><span class="line">	TRANS_UNDO        /* applying undo */  </span><br><span class="line">&#125; TransState;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>事务号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef uint64 TransactionId;  </span><br><span class="line"></span><br><span class="line">typedef uint64 GlobalTransactionId; /* 64-bit global transaction ids */  </span><br><span class="line"></span><br><span class="line">typedef uint32 ShortTransactionId;  </span><br><span class="line"></span><br><span class="line">typedef uint64 LocalTransactionId;  </span><br><span class="line"></span><br><span class="line">typedef uint64 SubTransactionId;  </span><br></pre></td></tr></table></figure>

<p>Top-level顶层事务通过VirtualTransactionIds(虚拟事务ID)区分，这个虚拟事务ID由运行xact的BackednId(后端ID) + LocalTransactionId(局部ID),不过一旦重启数据库，虚拟Id就会被重用，所以它不应该保存在硬盘上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct VirtualTransactionId &#123;</span><br><span class="line"></span><br><span class="line">    BackendId backendId;    /* determined at backend startup */</span><br><span class="line"></span><br><span class="line">    LocalTransactionId localTransactionId; /* backend-local transaction* id */</span><br><span class="line"></span><br><span class="line">&#125; VirtualTransactionId;</span><br></pre></td></tr></table></figure>

<ul>
<li>事务状态结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">transaction state structure</span><br><span class="line">   </span><br><span class="line">struct TransactionStateData &#123;</span><br><span class="line">#ifdef PGXC /* PGXC_COORD */ 根据参数决定使用哪种类型的成员结构</span><br><span class="line">    /* my GXID, or Invalid if none */</span><br><span class="line">    GlobalTransactionId transactionId; //全局事务id</span><br><span class="line">    GTM_TransactionKey txnKey;</span><br><span class="line">    bool isLocalParameterUsed; /* Check if a local parameter is active</span><br><span class="line">                                * in transaction block (SET LOCAL, DEFERRED) */</span><br><span class="line">    DList *savepointList;      /* SavepointData list */</span><br><span class="line">#else</span><br><span class="line">    TransactionId transactionId; /* my XID, or Invalid if none */ // 事务id</span><br><span class="line">#endif</span><br><span class="line">    SubTransactionId subTransactionId;   /* my subxact ID */</span><br><span class="line">    char *name;                          /* savepoint name, if any */ //回溯点名称</span><br><span class="line">    int savepointLevel;                  /* savepoint level */ 回溯点级别</span><br><span class="line"></span><br><span class="line">    TransState state;                    /* low-level state */</span><br><span class="line">    TBlockState blockState;              /* high-level state */</span><br><span class="line"></span><br><span class="line">    int nestingLevel;                    /* transaction nesting depth */事务嵌套深度</span><br><span class="line">    int gucNestLevel;                    /* GUC context nesting depth */ GUC上下文嵌套深度</span><br><span class="line"></span><br><span class="line">    MemoryContext curTransactionContext; /* my xact-lifetime context */ 事务上下文</span><br><span class="line">    ResourceOwner curTransactionOwner;   /* my query resources */ 事务所有者</span><br><span class="line"></span><br><span class="line">    TransactionId *childXids;            /* subcommitted child XIDs, in XID order */ 子事务</span><br><span class="line">    int nChildXids;                      /* # of subcommitted child XIDs */ 子事务的个数</span><br><span class="line">    int maxChildXids;                    /* allocated size of childXids[] */ 最多可容纳的子事务数</span><br><span class="line"></span><br><span class="line">    Oid prevUser;                        /* previous CurrentUserId setting */</span><br><span class="line">    int prevSecContext;                  /* previous SecurityRestrictionContext */ 安全限制上下文</span><br><span class="line">    bool prevXactReadOnly;               /* entry-time xact r/o state */</span><br><span class="line">    bool startedInRecovery;              /* did we start in recovery? */</span><br><span class="line">    bool didLogXid;                      /* has xid been included in WAL record? */</span><br><span class="line">    struct TransactionStateData* parent; /* back link to parent */ 回调用到的父事务id</span><br><span class="line">#ifdef ENABLE_MOT</span><br><span class="line">    /* which storage engine tables are used in current transaction for D/I/U/S statements */</span><br><span class="line">    StorageEngineType storageEngineType;</span><br><span class="line">#endif</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>


<h3 id="CSN机制"><a href="#CSN机制" class="headerlink" title="CSN机制"></a>CSN机制</h3><ol>
<li>CSN原理</li>
</ol>
<img src="C:\Users\24738\Desktop\CSN原理.png" alt="图片替换文本" width="1017" height="527" align="bottom"/>

<p>每个非只读事务在运行过程中会取得一个xid号，在事务提交时会推进CSN，同时会将当前CSN与事务的xid映射关系保存起来（CSNLOG）。上图中，实心竖线标识取snapshot（快照）时刻，会获取最新提交CSN（3）的下一个值4。TX1、TX3、TX5已经提交，对应的CSN号分别是1、2、3。TX2、TX4、TX6正在运行，TX7、TX8是未来还未开启的事务。对于当前snapshot而言，严格小于CSN号4的事务提交结果均可见；其余事务提交结果在获取快照时刻还未提交，不可见  </p>
<ol start="2">
<li>MVCC可见性判断(XidVisiblelnSnapshot())</li>
</ol>
<p>获取快照时记录当前<strong>活跃</strong>的<strong>最小</strong>的xid，记为snapshot.xmin。<br>当前<strong>最新提交</strong>的“事务id(latestCompleteXid) + 1”，记为snapshot.xmax。<br>当前最新提交的“CSN号 + 1”(NextCommitSeqNo)，记为snapshot.csn</p>
<img src="C:\Users\24738\Desktop\可见性判断.png" alt="图片替换文本" width="1017" height="527" align="bottom"/>

<p>1). xid大于等于snapshot.xmax时，该事务id不可见。<br>2). xid比snapshot.xmin小时，说明该事务id在本次事务启动以前已经结束，需要去CLOG查询事务的提交状态，并在元组头上设置相应的标记位。<br>3). xid处于snapshot.xmin和snapshot.xmax之间时，需要从CSN-XID映射中读取事务结束的CSN；如果CSN有值且比snapshot.csn小，表示该事务可见，否则不可见。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">描述：根据快照，指定xid是否可见</span><br><span class="line">返回：hintstatus标识事务的提交/终止</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">XidVisibleInSnapshot</span><span class="params">(TransactionId xid, Snapshot snapshot, TransactionIdStatus* hintstatus, Buffer buffer, <span class="type">bool</span>* sync)</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> CommitSeqNo csn;</span><br><span class="line">    <span class="type">bool</span> looped = <span class="literal">false</span>;</span><br><span class="line">    TransactionId parentXid = InvalidTransactionId;</span><br><span class="line">    *hintstatus = XID_INPROGRESS;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XIDVIS_DEBUG</span></span><br><span class="line">    <span class="built_in">ereport</span>(DEBUG1,</span><br><span class="line">        (<span class="built_in">errmsg</span>(<span class="string">&quot;XidVisibleInSnapshot xid %ld cur_xid %ld snapshot csn %lu xmax %ld&quot;</span>,</span><br><span class="line">            xid,</span><br><span class="line">            <span class="built_in">GetCurrentTransactionIdIfAny</span>(),</span><br><span class="line">            snapshot-&gt;snapshotcsn,</span><br><span class="line">            snapshot-&gt;xmax)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    大于等于xmax的xid都处于in-progress/aborted状态，不过在这里我们不做区分，我们无法利用xmin完成什么有用的操作</span></span><br><span class="line"><span class="comment">    因为它仅仅告诉我们这个xid是否已完成，我们必须去核查事务日志去判断事务所处的状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (GTM_MODE &amp;&amp; <span class="built_in">TransactionIdFollowsOrEquals</span>(xid, snapshot-&gt;xmax)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">loop:</span><br><span class="line">    csn = <span class="built_in">TransactionIdGetCommitSeqNo</span>(xid, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, snapshot); <span class="comment">/*获取提交序列号csn*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XIDVIS_DEBUG</span></span><br><span class="line">    <span class="built_in">ereport</span>(DEBUG1,</span><br><span class="line">        (<span class="built_in">errmsg</span>(<span class="string">&quot;XidVisibleInSnapshot xid %ld cur_xid %ld csn %ld snapshot&quot;</span></span><br><span class="line">                <span class="string">&quot;csn %ld xmax %ld&quot;</span>,</span><br><span class="line">            xid,</span><br><span class="line">            <span class="built_in">GetCurrentTransactionIdIfAny</span>(),</span><br><span class="line">            csn,</span><br><span class="line">            snapshot-&gt;snapshotcsn,</span><br><span class="line">            snapshot-&gt;xmax)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">COMMITSEQNO_IS_COMMITTED</span>(csn)) &#123;</span><br><span class="line">		<span class="comment">/*如果这个csn已经提交*/</span></span><br><span class="line">        *hintstatus = XID_COMMITTED; <span class="comment">//记录xid状态</span></span><br><span class="line">        <span class="keyword">if</span> (csn &lt; snapshot-&gt;snapshotcsn)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">COMMITSEQNO_IS_COMMITTING</span>(csn)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">            <span class="built_in">ereport</span>(DEBUG1, (<span class="built_in">errmsg</span>(<span class="string">&quot;transaction id %lu&#x27;s csn %ld is changed to ABORT after lockwait.&quot;</span>, xid, csn)));</span><br><span class="line">            <span class="comment">/* recheck if transaction id is finished */</span></span><br><span class="line">            <span class="built_in">RecheckXidFinish</span>(xid, csn);</span><br><span class="line">            <span class="built_in">CSNLogSetCommitSeqNo</span>(xid, <span class="number">0</span>, <span class="literal">NULL</span>, COMMITSEQNO_ABORTED);</span><br><span class="line">            <span class="built_in">SetLatestFetchState</span>(xid, COMMITSEQNO_ABORTED);</span><br><span class="line">            *hintstatus = XID_ABORTED;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">COMMITSEQNO_IS_SUBTRANS</span>(csn)) &#123;</span><br><span class="line">                <span class="comment">/* If snapshotcsn lower than csn stored in csn log, don&#x27;t need to wait. */</span></span><br><span class="line">                CommitSeqNo latestCSN = <span class="built_in">GET_COMMITSEQNO</span>(csn);</span><br><span class="line">                <span class="keyword">if</span> (latestCSN &gt;= snapshot-&gt;snapshotcsn) &#123;</span><br><span class="line">                    <span class="built_in">ereport</span>(DEBUG1,</span><br><span class="line">                        (<span class="built_in">errmsg</span>(</span><br><span class="line">                            <span class="string">&quot;snapshotcsn %lu lower than csn %lu stored in csn log, don&#x27;t need to sync wait, trx id %lu&quot;</span>,</span><br><span class="line">                            snapshot-&gt;snapshotcsn,</span><br><span class="line">                            csn,</span><br><span class="line">                            xid)));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parentXid = (TransactionId)<span class="built_in">GET_PARENTXID</span>(csn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u_sess-&gt;attr.attr_common.xc_maintenance_mode || u_sess-&gt;xact_cxt.bInAbortTransaction) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Wait for txn end and check again. */</span></span><br><span class="line">            <span class="keyword">if</span> (sync != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *sync = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">TransactionIdIsValid</span>(parentXid))</span><br><span class="line">                <span class="built_in">SyncWaitXidEnd</span>(parentXid, buffer);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">SyncWaitXidEnd</span>(xid, buffer);</span><br><span class="line">            looped = <span class="literal">true</span>;</span><br><span class="line">            parentXid = InvalidTransactionId;</span><br><span class="line">            <span class="keyword">goto</span> loop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (csn == COMMITSEQNO_ABORTED)</span><br><span class="line">            *hintstatus = XID_ABORTED;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>快照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Struct representing all kind of possible snapshots.</span><br><span class="line"></span><br><span class="line"> There are several different kinds of snapshots:</span><br><span class="line">    1.Normal MVCC snapshots</span><br><span class="line">    2.MVCC snapshots taken during recovery (in Hot-Standby mode)</span><br><span class="line">    3.Historic MVCC snapshots used during logical decoding</span><br><span class="line">    4.snapshots passed to HeapTupleSatisfiesDirty()</span><br><span class="line">    5.snapshots used for SatisfiesAny, Toast, Self where no members are</span><br><span class="line">    6.accessed.</span><br><span class="line"> </span><br><span class="line">    使用NodeTag将这个结构切分成若干个子结构，一种类型代表一种快照，从而避免但字段含义过载</span><br><span class="line"> */</span><br><span class="line">typedef struct SnapshotData &#123;</span><br><span class="line">    SnapshotSatisfiesMethod satisfies; /* satisfies type. */</span><br><span class="line">        剩余字段仅仅在MVCC中会用到，在特定快照中一般都是0 (But xmin and xmax are used</span><br><span class="line">        specially by HeapTupleSatisfiesDirty.)</span><br><span class="line">        MVCC无法表现出XIDs&gt;=xmax的影响，只能看到处理快照其外的其他XIDs的影响 </span><br><span class="line">        xmin is stored as an optimization to avoid needing to search the XID arrays</span><br><span class="line">        for most tuples.  </span><br><span class="line">    TransactionId xmin; /* all XID &lt; xmin are visible to me */</span><br><span class="line">    TransactionId xmax; /* all XID &gt;= xmax are invisible to me */</span><br><span class="line">        normal MVCC快照在处理过程中包含所有xact IDs,而historic快照正好相反，它包含xmin和xmax之间已提交的事务  </span><br><span class="line">    TransactionId* xip;</span><br><span class="line">        对于noe-historic MVCC 快照，在处理过程中包含subxact IDs,而historic 快照则是包含所有用于再现事务的xids  </span><br><span class="line">    TransactionId* subxip;</span><br><span class="line">    uint32 xcnt;           /* # of xact ids in xip[] */ xip数组中的元素数目</span><br><span class="line">    GTM_Timeline timeline; /* GTM timeline */</span><br><span class="line">#ifdef PGXC                /* PGXC_COORD */</span><br><span class="line">    uint32 max_xcnt;       /* Max # of xact in xip[] */</span><br><span class="line">#endif</span><br><span class="line">    /* note: all ids in xip[] satisfy xmin &lt;= xip[i] &lt; xmax */</span><br><span class="line">    int32 subxcnt;      /* # of xact ids in subxip[] */subxip数组中的元素数目</span><br><span class="line">    int32 maxsubxcnt;   /* # max xids could store in subxip[] */subxip数组最多可容纳的元素数目</span><br><span class="line">    bool suboverflowed; /* has the subxip array overflowed? */数组是否溢出</span><br><span class="line"></span><br><span class="line">    CommitSeqNo snapshotcsn;</span><br><span class="line">        这种快照可以表现出CSN&lt;=snapshotscn的事务的影响</span><br><span class="line">    int prepared_array_capacity;</span><br><span class="line">    int prepared_count;</span><br><span class="line">    TransactionId* prepared_array;</span><br><span class="line">         GTMLite local 快照，我们用一个数组保存所有用于MVCC的已备事务xids </span><br><span class="line"></span><br><span class="line">    bool takenDuringRecovery; /* recovery-shaped snapshot? */</span><br><span class="line">    bool copied;              /* false if it&#x27;s a static snapshot */</span><br><span class="line">        所有在subxip数组中的ids都&gt;=xmin,我们不需要过滤出那些&gt;=xmax的ids</span><br><span class="line">    CommandId curcid;    /* in my xact, CID &lt; curcid are visible */</span><br><span class="line">    uint32 active_count; /* refcount on ActiveSnapshot stack */</span><br><span class="line">    uint32 regd_count;   /* refcount on RegisteredSnapshotList */</span><br><span class="line">    void* user_data;     /* for local multiversion snapshot */</span><br><span class="line">    GTM_SnapshotType gtm_snapshot_type;</span><br><span class="line">&#125; SnapshotData;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>事务存储</li>
</ul>
<p>在HeapTupleHeader中存在有操作该元组的事务号，可用于判断元组的可见性<br>当事务插入时，会将事务信息写道xmin中去，表示插入该元组的xid；当事务进行更新或删除时，将事务信息写道xmax中去,表示删除该元组的xid.结构如下：<br><img src="C:\Users\24738\Desktop\dywkc1ujse.png" alt="图片替换文本" width="274" height="75" align="bottom"/></p>
<p>事务号是uint64单调递增序列，为了节省空间以及兼容老的版本，元组头部的xmin&#x2F;xmax存储为：<code>xid_base(uint64)+xmin/xmax(uint32)</code>。属于同一个页面的元组会共用同一个页面基本的xid_base以节省空间。<br><img src="C:\Users\24738\Desktop\xrxn3dbdgn.png" alt="图片替换文本" width="274" height="75" align="bottom"/></p>
<ul>
<li>CLOG&#x2F;CSNLOG</li>
</ul>
<p>CLOG用于记录事务的提交状态，每个事务号用4bit标识它的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define CLOG_XID_STATUS_IN_PROGRESS 0x00</span><br><span class="line">#define CLOG_XID_STATUS_COMMITTED 0x01</span><br><span class="line">#define CLOG_XID_STATUS_ABORTED 0x02</span><br><span class="line">/*</span><br><span class="line"> * A &quot;subcommitted&quot; transaction is a committed subtransaction whose parent</span><br><span class="line"> * hasn&#x27;t committed or aborted yet.</span><br><span class="line"> */</span><br><span class="line">#define CLOG_XID_STATUS_SUB_COMMITTED 0x03</span><br></pre></td></tr></table></figure>
<p>CLOG文件存储结构如下：<br>  1）物理存储文件内容<br>  2) 文件对应的事务id逻辑编号<br>  3） 2bit保存事务的CLOG存储空间</p>
<p>CSNLOG文件存储结构如下：<br>   1）CNSLOG物理存储<br>   2）文件对应的事务id逻辑编号<br>   3)  8bytes保存对应事务的CSNLOG空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* thread local pointer to the shared memory */</span><br><span class="line">typedef struct knl_t_shemem_ptr_context &#123;</span><br><span class="line">  ...</span><br><span class="line">        struct SlruCtlData* ClogCtl;</span><br><span class="line">        struct SlruCtlData* CsnlogCtlPtr;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CLOG写流程（各函数）"><a href="#CLOG写流程（各函数）" class="headerlink" title="CLOG写流程（各函数）"></a>CLOG写流程（各函数）</h3><ul>
<li>CLogSetTreeStatus函数</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CLogSetTreeStatus</span>(<span class="params">TransactionId xid, <span class="built_in">int</span> nsubxids, TransactionId *subxids, CLogXidStatus status, XLogRecPtr lsn</span>)</span>&#123;  </span><br><span class="line"></span><br><span class="line">    int64 pageno = (int64)TransactionIdToPage(xid); <span class="comment">/* get page of parent */</span> 获取这个事务对应的page号  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SECUREC_UNLIKELY(!(status == CLOG_XID_STATUS_COMMITTED || status == CLOG_XID_STATUS_ABORTED)))  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果CLOG既未提交也为抛出，说明CLOG出现了问题  </span></span><br><span class="line"></span><br><span class="line">        ereport(PANIC, (errmsg(<span class="string">&quot;CLOG STATUS ERROR: xid %lu status %s&quot;</span>, xid, GetTransactionStatus(status))));  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SHOW_DEBUG_MESSAGE()) &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == CLOG_XID_STATUS_COMMITTED)  </span><br><span class="line"></span><br><span class="line">            ereport(DEBUG1, (errmsg(<span class="string">&quot;Record transaction commit &quot;</span> XID_FMT, xid)));  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line"></span><br><span class="line">            ereport(DEBUG1, (errmsg(<span class="string">&quot;Record transaction abort &quot;</span> XID_FMT, xid)));  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">//确定主事务下边有多少子事务与其处于同一页上  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nsubxids; i++) &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((int64)TransactionIdToPage(subxids[i]) != pageno)  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据情况分别处理子事务  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == nsubxids) &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有子事务均与主事务处于同一页面  </span></span><br><span class="line"></span><br><span class="line">        CLogSetPageStatus(xid, nsubxids, subxids, status, lsn, pageno, <span class="literal">true</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个参数标识子事务的个数  </span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> nsubxids_on_first_page = i;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，我们知道我们需要更新不止一页的 clog，所以在第一页上标记 *not* 的条目，以便它们显示为已提交，然后我们返回以将状态更新为完全提交。为避免两次接触第一页，请跳过为该第一页上的 subxid 标记已提交  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == CLOG_XID_STATUS_COMMITTED)  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 参数1：处于不同页面的子事务个数， 参数2：这些子事务放置的位置， 参数3：应该赋予的状态  </span></span><br><span class="line"></span><br><span class="line">            set_status_by_pages(nsubxids - nsubxids_on_first_page, subxids + nsubxids_on_first_page, CLOG_XID_STATUS_SUB_COMMITTED, lsn);  </span><br><span class="line"></span><br><span class="line">        pageno = (int64)TransactionIdToPage(xid);  </span><br><span class="line"></span><br><span class="line">        CLogSetPageStatus(xid, nsubxids_on_first_page, subxids, status, lsn, pageno, <span class="literal">false</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新在设置一遍  </span></span><br><span class="line"></span><br><span class="line">        set_status_by_pages(nsubxids - nsubxids_on_first_page, subxids + nsubxids_on_first_page, status, lsn);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>CLogSetPageStatus()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Description: 记录一个页面上所有事务的最终状态  </span><br><span class="line">xid -  事务ID  </span><br><span class="line">nsubxids - 子事务的个数  </span><br><span class="line">subxids - 子事务数组  </span><br><span class="line">status -  clog状态  </span><br><span class="line">lsn - the lsn <span class="keyword">for</span> xlog record  </span><br><span class="line">pageno - 主事务的页号  </span><br><span class="line">all_xact_same_page - 记录是否所有的子事务均与主事务处于同一页面  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CLogSetPageStatus</span><span class="params">(TransactionId xid, <span class="type">int</span> nsubxids, TransactionId *subxids, CLogXidStatus status, XLogRecPtr lsn, int64 pageno, <span class="type">bool</span> all_xact_same_page)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Can&#x27;t use group update when PGPROC overflows. */</span></span><br><span class="line">    <span class="built_in">StaticAssertStmt</span>(THRESHOLD_SUBTRANS_CLOG_OPT &lt;= PGPROC_MAX_CACHED_SUBXIDS, <span class="string">&quot;group clog threshold less than PGPROC cached subxids&quot;</span>);</span><br><span class="line">    <span class="comment">// 当存在ClogCtl(pageno)-&gt;shared-&gt;control_lock的锁竞争时，将更新分成多组</span></span><br><span class="line">    <span class="comment">// 这样单个leader进程就会为多个后端更新事务状态，从而减少竞争的次数</span></span><br><span class="line">    <span class="comment">// 当子事务个数为超过阈值，t_thrd.proc中的子事务个数与传入的子事务个数相同</span></span><br><span class="line">    <span class="keyword">if</span> (all_xact_same_page &amp;&amp; xid == t_thrd.pgxact-&gt;xid &amp;&amp; nsubxids &lt;= THRESHOLD_SUBTRANS_CLOG_OPT &amp;&amp;</span><br><span class="line">        nsubxids == t_thrd.pgxact-&gt;nxids &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(subxids, t_thrd.proc-&gt;subxids.xids, (<span class="type">size_t</span>)(nsubxids * <span class="built_in">sizeof</span>(TransactionId))) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组溢出，我们就不需要优化了</span></span><br><span class="line">        <span class="built_in">Assert</span>(THRESHOLD_SUBTRANS_CLOG_OPT &lt;= PGPROC_MAX_CACHED_SUBXIDS);</span><br><span class="line">        <span class="comment">// 如果我们可以立即完成ClogCtl(pageno)-&gt;shared-&gt;control_lock的过程，我们既可以更新主事务的状态并且释放锁，如果不能完成，则借助组更新，如果二者皆无法起作用，等待直至完成这个任务为止</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LWLockConditionalAcquire</span>(<span class="built_in">ClogCtl</span>(pageno)-&gt;shared-&gt;control_lock, LW_EXCLUSIVE) &#123;</span><br><span class="line">            <span class="comment">// 无需等待，更新状态然后释放锁</span></span><br><span class="line">            <span class="built_in">CLogSetPageStatusInternal</span>(xid, nsubxids, subxids, status, lsn, pageno);</span><br><span class="line">            <span class="built_in">LWLockRelease</span>(<span class="built_in">ClogCtl</span>(pageno)-&gt;shared-&gt;control_lock);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CLogGroupUpdateXidStatus</span>(xid, status, lsn, pageno)) &#123;</span><br><span class="line">            <span class="comment">// 借助组机制完成更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Fall through only if update isn&#x27;t done yet. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 组更新不可用，或者未能成功获取页号,再走一遍上述步骤 */</span></span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">LWLockAcquire</span>(<span class="built_in">ClogCtl</span>(pageno)-&gt;shared-&gt;control_lock, LW_EXCLUSIVE);</span><br><span class="line">    <span class="built_in">CLogSetPageStatusInternal</span>(xid, nsubxids, subxids, status, lsn, pageno);</span><br><span class="line">    <span class="built_in">LWLockRelease</span>(<span class="built_in">ClogCtl</span>(pageno)-&gt;shared-&gt;control_lock);</span><br></pre></td></tr></table></figure>

<ul>
<li>CLogGroupUpdateXidStatus()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当我们在独占模式下无法立即获取到锁时，会将我们自己添加到待更新列表中去</span><br><span class="line">首个将自己添加到列表中却进程将会获取到锁，然后代表所有组员设置事务状态</span><br><span class="line">由于不需要从一个进程传递给下一个进程，所以这里避免了的所得竞争  </span><br><span class="line">如果成功更新，返回true  </span><br><span class="line">而如果我们需要更新的页号与正在等待的进程不同，则不做优化处理，返回false  </span><br><span class="line"></span><br><span class="line">static bool CLogGroupUpdateXidStatus(TransactionId xid, CLogXidStatus status, XLogRecPtr lsn, int64 pageno)</span><br><span class="line">&#123;</span><br><span class="line">    PGPROC *proc = t_thrd.proc;</span><br><span class="line">    uint32 nextidx;</span><br><span class="line">    uint32 wakeidx;</span><br><span class="line">    // 确定这个事务是否需要更新</span><br><span class="line">    Assert(TransactionIdIsValid(xid));</span><br><span class="line">    // 将自身添加到进程列表中去</span><br><span class="line">    proc-&gt;clogGroupMember = true;</span><br><span class="line">    proc-&gt;clogGroupMemberXid = xid;</span><br><span class="line">    proc-&gt;clogGroupMemberXidStatus = status;</span><br><span class="line">    proc-&gt;clogGroupMemberPage = pageno;</span><br><span class="line">    proc-&gt;clogGroupMemberLsn = lsn;</span><br><span class="line">    nextidx = pg_atomic_read_u32(&amp;g_instance.proc_base-&gt;clogGroupFirst);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 如果当前事务的clog页面与组长页面相同，将proc添加到列表中</span><br><span class="line">        // 这里存在一个竞态条件：在进行下述检查后，再将proc的clog添加到组之前，组长可能已经完后</span><br><span class="line">        // 了这个页面的更新并成为了另一个组的组长，这将导致一个组有则不同的clog页面更新      </span><br><span class="line">        // 这种可能行不大，不过会降低效率</span><br><span class="line">        if (nextidx != INVALID_PGPROCNO &amp;&amp;</span><br><span class="line">            g_instance.proc_base_all_procs[nextidx]-&gt;clogGroupMemberPage != proc-&gt;clogGroupMemberPage) &#123;</span><br><span class="line">            proc-&gt;clogGroupMember = false;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pg_atomic_write_u32(&amp;proc-&gt;clogGroupNext, nextidx);</span><br><span class="line">        if (pg_atomic_compare_exchange_u32(&amp;g_instance.proc_base-&gt;clogGroupFirst, &amp;nextidx, (uint32)proc-&gt;pgprocno))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果列表非空，组长就会更新成员状态，</span><br><span class="line">    if (nextidx != INVALID_PGPROCNO) &#123;</span><br><span class="line">        int extraWaits = 0;</span><br><span class="line">        /* Sleep until the leader updates our XID status. */</span><br><span class="line">        // 阻塞至组长更新本事务状态</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            /* acts as a read barrier */</span><br><span class="line">            PGSemaphoreLock(&amp;proc-&gt;sem, false);</span><br><span class="line">            if (!proc-&gt;clogGroupMember)</span><br><span class="line">                break;</span><br><span class="line">            extraWaits++;</span><br><span class="line">        &#125;</span><br><span class="line">        Assert(pg_atomic_read_u32(&amp;proc-&gt;clogGroupNext) == INVALID_PGPROCNO);</span><br><span class="line">        /* Fix semaphore count for any absorbed wakeups */</span><br><span class="line">        while (extraWaits-- &gt; 0)</span><br><span class="line">            PGSemaphoreUnlock(&amp;proc-&gt;sem);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 组长会代表组员获取锁</span><br><span class="line">    (void)LWLockAcquire(ClogCtl(pageno)-&gt;shared-&gt;control_lock, LW_EXCLUSIVE);</span><br><span class="line">    在我们拿到锁之后，清空列表，保存链头指针。一次出栈一个元素就有可能导致ABA问题；</span><br><span class="line">    </span><br><span class="line">    ABA问题：</span><br><span class="line"> ​       ABA 问题的过程是当有两个线程 T1 和 T2 从内存中获取到值A，</span><br><span class="line">        线程 T2 通过某些操作把内存 值修改为B，然后又经过某些操作将值修改为回值A，T2退出。</span><br><span class="line">        线程 T1 进行操作的时候 ，使用预期值同内存中的值比较，此时均为A，修改成功退出。但是此时的A以及不是原先的A了，这就是 ABA 问题</span><br><span class="line">    nextidx = pg_atomic_exchange_u32(&amp;g_instance.proc_base-&gt;clogGroupFirst, INVALID_PGPROCNO);</span><br><span class="line">    /* Remember head of list so we can perform wakeups after dropping lock. */</span><br><span class="line">    wakeidx = nextidx;</span><br><span class="line">   // 遍历列表，更新所有的事务状态</span><br><span class="line">    while (nextidx != INVALID_PGPROCNO) &#123;</span><br><span class="line">        proc = g_instance.proc_base_all_procs[nextidx];</span><br><span class="line">        PGXACT *pgxact = &amp;g_instance.proc_base_all_xacts[nextidx];</span><br><span class="line">        CLogSetPageStatusInternal(proc-&gt;clogGroupMemberXid, pgxact-&gt;nxids, proc-&gt;subxids.xids,proc-&gt;clogGroupMemberXidStatus, proc-&gt;clogGroupMemberLsn, proc-&gt;clogGroupMemberPage);</span><br><span class="line">        /* Move to next proc in list. */</span><br><span class="line">        nextidx = pg_atomic_read_u32(&amp;proc-&gt;clogGroupNext);</span><br><span class="line">    &#125;</span><br><span class="line">    释放锁，保证最短的锁占用时间</span><br><span class="line">    LWLockRelease(ClogCtl(pageno)-&gt;shared-&gt;control_lock);</span><br><span class="line"></span><br><span class="line">    while (wakeidx != INVALID_PGPROCNO) &#123;</span><br><span class="line">        proc = g_instance.proc_base_all_procs[wakeidx];</span><br><span class="line">        wakeidx = pg_atomic_read_u32(&amp;proc-&gt;clogGroupNext);</span><br><span class="line">        pg_atomic_write_u32(&amp;proc-&gt;clogGroupNext, INVALID_PGPROCNO);</span><br><span class="line">        确保组员在操作之前，之前所有写入均可见</span><br><span class="line">        pg_write_barrier();</span><br><span class="line">        proc-&gt;clogGroupMember = false;</span><br><span class="line">        if (proc != t_thrd.proc)</span><br><span class="line">            PGSemaphoreUnlock(&amp;proc-&gt;sem);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br></pre></td></tr></table></figure>

<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul>
<li>AssignTransactionId()：事务号分配<br>每一个写事务均会分配一个唯一标识(xid)，只读事务不分配xid</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AssignTransactionId</span><br><span class="line">只调用之前，不为事务分配xid,父事务的xid总是在子事务之前分配</span><br><span class="line">static void AssignTransactionId(TransactionState s) &#123;</span><br><span class="line">    bool isSubXact = (s-&gt;parent != NULL); // 判断当前事务是父事务还是子事务</span><br><span class="line">    ResourceOwner currentOwner;</span><br><span class="line">    bool log_unknown_top = false;</span><br><span class="line">    // 确保事务未被赋予过xid，并且其还处于处理过程中</span><br><span class="line">    Assert(!TransactionIdIsValid(s-&gt;transactionId));</span><br><span class="line">    Assert(s-&gt;state == TRANS_INPROGRESS);</span><br><span class="line">    //确保父事务有xid,否则有可能导致栈溢出</span><br><span class="line">    if (isSubXact &amp;&amp; !TransactionIdIsValid(s-&gt;parent-&gt;transactionId)) &#123;</span><br><span class="line">        TransactionState p = s-&gt;parent;</span><br><span class="line">        //这里我们需要不断向上寻找父事务，直到其有有效xid为止</span><br><span class="line">        TransactionState *parents = NULL;</span><br><span class="line">        size_t parentOffset = 0;</span><br><span class="line">        parents = (TransactionState *)palloc(sizeof(TransactionState) * s-&gt;nestingLevel);</span><br><span class="line">        while (p != NULL &amp;&amp; !TransactionIdIsValid(p-&gt;transactionId)) &#123;</span><br><span class="line">            parents[parentOffset++] = p;</span><br><span class="line">            p = p-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        为所有上级父事务分配xid后释放空间</span><br><span class="line">        while (parentOffset != 0)</span><br><span class="line">            AssignTransactionId(parents[--parentOffset]);</span><br><span class="line">        pfree(parents);</span><br><span class="line">    &#125;</span><br><span class="line">    // 当wal_level为logical时，如果子事务的顶层xid之前记录过，确保它的xid只能在WAL流中可见</span><br><span class="line">    // 如有必要，我们会记录一个小于PGPROC_MAX_CACHED_SUBXIDS的xact_assignment,如果一个事务并未 </span><br><span class="line">    // 设置didLogXid,即使它出现在WAL记录中也没什么事，系统会记录一些无关紧要的东西。</span><br><span class="line"></span><br><span class="line">    if (isSubXact &amp;&amp; XLogLogicalInfoActive() &amp;&amp; !TopTransactionStateData.didLogXid)</span><br><span class="line">        log_unknown_top = true;</span><br><span class="line">    /* allocate undo zone before generate a new xid. */</span><br><span class="line">    if (!isSubXact &amp;&amp; IsUnderPostmaster) &#123;</span><br><span class="line">        undo::AllocateUndoZone();</span><br><span class="line">        pg_memory_barrier();</span><br><span class="line">    &#125;</span><br><span class="line">    // 生成一个新的xid,将其记录在PG——PROC和pg_subtrans中</span><br><span class="line">    // 我们需要在xid出现在PG_PROC以外的共享内存之前，设置子事务条目</span><br><span class="line">    // 因为，如果PG_PROC中没有空间，需要子事务条目让其他后端将这个xid视为正在运行</span><br><span class="line"></span><br><span class="line">#ifdef PGXC /* PGXC_COORD */</span><br><span class="line">    s-&gt;transactionId = GetNewTransactionId(isSubXact, s);</span><br><span class="line">#else</span><br><span class="line">    s-&gt;transactionId = GetNewTransactionId(isSubXact);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    if (!isSubXact) &#123;</span><br><span class="line">        ProcXactHashTableAdd(s-&gt;transactionId, t_thrd.proc-&gt;pgprocno);</span><br><span class="line">    &#125;</span><br><span class="line">    /* send my top transaction id to exec CN */</span><br><span class="line">    if (!isSubXact &amp;&amp; IsConnFromCoord() &amp;&amp; u_sess-&gt;need_report_top_xid)</span><br><span class="line">        ReportTopXid(s-&gt;transactionId);</span><br><span class="line">    if (!isSubXact)</span><br><span class="line">        instr_stmt_report_txid(s-&gt;transactionId);</span><br><span class="line">    FixCurrentSnapshotByGxid(s-&gt;transactionId);</span><br><span class="line">    if (isSubXact)</span><br><span class="line">        SubTransSetParent(s-&gt;transactionId, s-&gt;parent-&gt;transactionId);</span><br><span class="line">    /*</span><br><span class="line">     * If it&#x27;s a top-level transaction, the predicate locking system needs to</span><br><span class="line">     * be told about it too.</span><br><span class="line">     */</span><br><span class="line">    if (!isSubXact)</span><br><span class="line">        RegisterPredicateLockingXid(s-&gt;transactionId);</span><br><span class="line">    /*</span><br><span class="line">     * Acquire lock on the transaction XID.  (We assume this cannot block.) We</span><br><span class="line">     * have to ensure that the lock is assigned to the transaction&#x27;s own</span><br><span class="line">     * ResourceOwner.</span><br><span class="line">     */</span><br><span class="line">    currentOwner = t_thrd.utils_cxt.CurrentResourceOwner;</span><br><span class="line">    PG_TRY();</span><br><span class="line">    &#123;</span><br><span class="line">        t_thrd.utils_cxt.CurrentResourceOwner = s-&gt;curTransactionOwner;</span><br><span class="line">        XactLockTableInsert(s-&gt;transactionId);</span><br><span class="line">    &#125;</span><br><span class="line">    PG_CATCH();</span><br><span class="line">    &#123;</span><br><span class="line">        /* Ensure CurrentResourceOwner is restored on error */</span><br><span class="line">        t_thrd.utils_cxt.CurrentResourceOwner = currentOwner;</span><br><span class="line">        PG_RE_THROW();</span><br><span class="line">    &#125;</span><br><span class="line">    PG_END_TRY();</span><br><span class="line">    t_thrd.utils_cxt.CurrentResourceOwner = currentOwner;</span><br><span class="line">    /*</span><br><span class="line">     * Every PGPROC_MAX_CACHED_SUBXIDS assigned transaction ids within each</span><br><span class="line">     * top-level transaction we issue a WAL record for the assignment. We</span><br><span class="line">     * include the top-level xid and all the subxids that have not yet been</span><br><span class="line">     * reported using XLOG_XACT_ASSIGNMENT records.</span><br><span class="line">     *</span><br><span class="line">     * This is required to limit the amount of shared memory required in a hot</span><br><span class="line">     * standby server to keep track of in-progress XIDs.</span><br><span class="line">     * See notes for RecordKnownAssignedTransactionIds().</span><br><span class="line">     *</span><br><span class="line">     * We don&#x27;t keep track of the immediate parent of each subxid, only the</span><br><span class="line">     * top-level transaction that each subxact belongs to. This is correct in</span><br><span class="line">     * recovery only because aborted subtransactions are separately WAL</span><br><span class="line">     * logged.</span><br><span class="line">     *</span><br><span class="line">     * This is correct even for the case where several levels above us didn&#x27;t</span><br><span class="line">     * have an xid assigned as we recursed up to them beforehand.</span><br><span class="line">     */</span><br><span class="line">    if (isSubXact &amp;&amp; XLogStandbyInfoActive()) &#123;</span><br><span class="line">        u_sess-&gt;xact_cxt.unreportedXids[u_sess-&gt;xact_cxt.nUnreportedXids] = s-&gt;transactionId;</span><br><span class="line">        u_sess-&gt;xact_cxt.nUnreportedXids++;</span><br><span class="line">        /*</span><br><span class="line">         * ensure this test matches similar one in RecoverPreparedTransactions()</span><br><span class="line">         */</span><br><span class="line">        if (u_sess-&gt;xact_cxt.nUnreportedXids &gt;= PGPROC_MAX_CACHED_SUBXIDS || log_unknown_top) &#123;</span><br><span class="line">            xl_xact_assignment xlrec;</span><br><span class="line">            /*</span><br><span class="line">             * xtop is always set by now because we recurse up transaction</span><br><span class="line">             * stack to the highest unassigned xid and then come back down</span><br><span class="line">             */</span><br><span class="line">            xlrec.xtop = GetTopTransactionId();</span><br><span class="line">            Assert(TransactionIdIsValid(xlrec.xtop));</span><br><span class="line">            xlrec.nsubxacts = u_sess-&gt;xact_cxt.nUnreportedXids;</span><br><span class="line">            XLogBeginInsert();</span><br><span class="line">            XLogRegisterData((char *)&amp;xlrec, MinSizeOfXactAssignment);</span><br><span class="line">            XLogRegisterData((char *)u_sess-&gt;xact_cxt.unreportedXids,</span><br><span class="line">                             u_sess-&gt;xact_cxt.nUnreportedXids * sizeof(TransactionId));</span><br><span class="line">            (void)XLogInsert(RM_XACT_ID, XLOG_XACT_ASSIGNMENT);</span><br><span class="line">            u_sess-&gt;xact_cxt.nUnreportedXids = 0;</span><br><span class="line">            /* mark top, not current xact as having been logged */</span><br><span class="line">            TopTransactionStateData.didLogXid = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>GetNewTransactionId()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 在我们调用这个函数之前，就已经在有效xid内了，这是因为在没有xid之前，事务不能有任何动作。</span><br><span class="line">// 那么，如果我们要报一个xid换行的警告，去查找数据库也是安全的。</span><br><span class="line">#ifdef PGXC // 可选是否使用传入的状态</span><br><span class="line">TransactionId GetNewTransactionId(bool isSubXact, TransactionState s)</span><br><span class="line">#else</span><br><span class="line">TransactionId GetNewTransactionId(bool isSubXact)</span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">    volatile TransactionId xid; // 为xid添加volatile特性，是为了防止在try,catch语句中被改变</span><br><span class="line">#ifdef PGXC</span><br><span class="line">    bool increment_xid = true;</span><br><span class="line">#endif</span><br><span class="line">    //在引导程序初始化期间，我们返回特殊的引导事务id</span><br><span class="line"></span><br><span class="line">    if (IsBootstrapProcessingMode()) &#123;</span><br><span class="line">        Assert(!isSubXact);</span><br><span class="line">        t_thrd.pgxact-&gt;xid = BootstrapTransactionId;</span><br><span class="line">        return BootstrapTransactionId;</span><br><span class="line">    &#125;</span><br><span class="line">    /* safety check, we should never get this far in a HS slave */</span><br><span class="line">    if (RecoveryInProgress())</span><br><span class="line">        ereport(ERROR, (errcode(ERRCODE_INVALID_TRANSACTION_INITIATION),</span><br><span class="line">                        errmsg(&quot;cannot assign TransactionIds during recovery&quot;)));</span><br><span class="line">    if (GTM_MODE) &#123;</span><br><span class="line">              ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        (void)LWLockAcquire(XidGenLock, LW_EXCLUSIVE);</span><br><span class="line">        xid = u_sess-&gt;xact_cxt.ShmemVariableCache-&gt;nextXid;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查分配另一个xid是否安全，也即判断xid &gt; xidVacLimit,如果满足条件会进行autovac</span><br><span class="line">    if (TransactionIdFollowsOrEquals(xid, u_sess-&gt;xact_cxt.ShmemVariableCache-&gt;xidVacLimit)) &#123;</span><br><span class="line">        // 出于安全考虑，我们在发送信号、警告期间会释放XidGenLock，这并不是我们并不关心保留并发性，</span><br><span class="line">        // 而是为了避免在执行get_database_name()时发生死锁</span><br><span class="line">        // 首先，拷贝我们需要的所有的共享值</span><br><span class="line">        LWLockRelease(XidGenLock);</span><br><span class="line"></span><br><span class="line">        // 为了避免让postmaster淹没在信号中，我们每4K事务只发其一次autovac请求</span><br><span class="line">        if (IsUnderPostmaster &amp;&amp; (xid % 65536) == 0)</span><br><span class="line">            SendPostmasterSignal(PMSIGNAL_START_AUTOVAC_LAUNCHER);</span><br><span class="line"></span><br><span class="line">        // 重新获取锁，然后重新开始</span><br><span class="line">        (void)LWLockAcquire(XidGenLock, LW_EXCLUSIVE);</span><br><span class="line">        /* Make the logical same to PG when GTM-Free */</span><br><span class="line">        if (!GTM_MODE)</span><br><span class="line">            xid = u_sess-&gt;xact_cxt.ShmemVariableCache-&gt;nextXid;</span><br><span class="line">#ifndef PGXC</span><br><span class="line">        // 在Postgres-XC情况下，事务ID在GTM级别全局管理，在这基于有可能被另一个会话改变的缓存更新GXID，</span><br><span class="line">        // 当在本地结点级别检查环绕错误时，会破坏集群事务ID的一致性</span><br><span class="line"></span><br><span class="line">        xid = u_sess-&gt;xact_cxt.ShmemVariableCache-&gt;nextXid;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    // 如果我们正在分配CLOG新页面的首个xid,在返回前这个CLOG页面前会将被清空。</span><br><span class="line">    // 我们必须在持有XidGenLock时才能执行这个操作，否则另一个xact可能会在我们将页面清空之前获取并提交一个xid.</span><br><span class="line">    // 幸运的是，CLOG的页面一般有着32K或者更大的事务，我们不需要经常这么做</span><br><span class="line"></span><br><span class="line">    // 扩展到pg_subtrans中也是一样</span><br><span class="line">    ExtendCLOG(xid);</span><br><span class="line">    ExtendCSNLOG(xid);</span><br><span class="line">    if (GTM_MODE) &#123;</span><br><span class="line">              ...</span><br><span class="line">    &#125; else</span><br><span class="line">        TransactionIdAdvance(u_sess-&gt;xact_cxt.ShmemVariableCache-&gt;nextXid);</span><br><span class="line">    // 我们必须在释放XidGenLock锁之前将这个新的xid保存到公共procArray中去，确保每一个早于latestCompletedXid活跃的XID出现在</span><br><span class="line">    // ProcArray,这对于正确追踪OldestXmin至关重要。src/backend/access/transam/README.</span><br><span class="line"></span><br><span class="line">    // XXX无需获取ProcArrayLock锁就将xid保存到MyPgXact，我们需要依赖于获取/存储xid都是原子性，否则其他后端可能会看到设置不完全的xid.</span><br><span class="line">    // 但是同时持有多把锁，就引起并发问题，所以需要假定原子性</span><br><span class="line">    // 对于用户而言，PGXACT的xid字段只需要获取一次即可，不需要假定可以多次读，且每次读的结果都相同，这个问题同样适用于subxact xid的计数和溢出字段</span><br><span class="line">    // 原子存储问题可以通过使用自旋锁来实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 如果没有空间将子事务的xid存放在PGPROC中，可以设置缓存溢出标志</span><br><span class="line">    // 这就要求读者阅读pg-subtrans将子事务的xid映射到顶层xid,这里存在一个竞态窗口，新的xid在其父链接放到pg_subtrans之前不会运行，不过只会发生在用户请求获        取xid状态之前，这似乎也没什么问题</span><br><span class="line">    // 在这个窗口期间快照会包含父xid，当确实有人请求时，快照会发送正确的答案</span><br><span class="line">    &#123;</span><br><span class="line">        // 使用volatile指针是为了防止重排，其他后端也可能并发检测我的subxids 信息，为了不让他们看到无效的中间状态（例如，在填充数组之前会自增nxids）,我们假设事务的获取/保存都是原子的</span><br><span class="line">        volatile PGPROC *myproc = t_thrd.proc;</span><br><span class="line">        volatile PGXACT *mypgxact = t_thrd.pgxact;</span><br><span class="line">        if (!isSubXact) &#123;</span><br><span class="line">            // 如果没有子处理，进保存本事务xid即可</span><br><span class="line">            if (GTM_MODE)</span><br><span class="line">                mypgxact-&gt;handle = GetTransactionHandleIfAny(s);</span><br><span class="line">            mypgxact-&gt;xid = xid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int nxids = mypgxact-&gt;nxids;</span><br><span class="line">            /* Allocate or realloc memory if needed */</span><br><span class="line">            if (myproc-&gt;subxids.maxNumber == 0 || nxids &gt;= myproc-&gt;subxids.maxNumber) &#123;</span><br><span class="line">                // 如果subxurs.maxNumber = 0 或者其不大于于nxids</span><br><span class="line">                Assert(ProcSubXidCacheContext); // subxid缓存上下文</span><br><span class="line">                if (myproc-&gt;subxids.maxNumber == 0) &#123;</span><br><span class="line">                    /* Init memory */</span><br><span class="line">                    HOLD_INTERRUPTS(); // 保持中断</span><br><span class="line">                    MemoryContext oldContext = MemoryContextSwitchTo(ProcSubXidCacheContext); //上下文切换</span><br><span class="line">                    // 分配内存，保存已缓存的subxid</span><br><span class="line">                    myproc-&gt;subxids.xids = (TransactionId *)palloc(sizeof(TransactionId) * PGPROC_INIT_CACHED_SUBXIDS);</span><br><span class="line">                    myproc-&gt;subxids.maxNumber = PGPROC_INIT_CACHED_SUBXIDS;</span><br><span class="line">                    (void)MemoryContextSwitchTo(oldContext); // 上下文切换</span><br><span class="line">                    RESUME_INTERRUPTS(); // 恢复中断</span><br><span class="line">                &#125; else if (nxids &gt;= myproc-&gt;subxids.maxNumber) &#123;</span><br><span class="line">                    int maxNumber = myproc-&gt;subxids.maxNumber * 2; // 修改数组容量上限</span><br><span class="line">                    /* Realloc, use subxidsLock to protect subxids */</span><br><span class="line">                    (void)LWLockAcquire(myproc-&gt;subxidsLock, LW_EXCLUSIVE); // 加锁</span><br><span class="line">                    myproc-&gt;subxids.xids = (TransactionId *)repalloc(myproc-&gt;subxids.xids,sizeof(TransactionId) * maxNumber);</span><br><span class="line">                    myproc-&gt;subxids.maxNumber = maxNumber;</span><br><span class="line">                    LWLockRelease(myproc-&gt;subxidsLock); // 解锁</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将本事务的xid也添加到数组中取</span><br><span class="line">            myproc-&gt;subxids.xids[nxids] = xid;</span><br><span class="line">            mypgxact-&gt;nxids = nxids + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当我们使用局部快照时，最新已完成的xid对我们而言很重要</span><br><span class="line">    // 如果处于非GTM_MODE，lastestCompletedXid &lt;= xid，报告错误信息</span><br><span class="line">    if (!GTM_MODE &amp;&amp; TransactionIdFollowsOrEquals(u_sess-&gt;xact_cxt.ShmemVariableCache-&gt;latestCompletedXid, xid))</span><br><span class="line">        ereport(PANIC, (errcode(ERRCODE_INVALID_TRANSACTION_STATE),</span><br><span class="line">                        errmsg(&quot;GTM-FREE-MODE: latestCompletedXid %lu larger than next alloc xid %lu.&quot;,</span><br><span class="line">                               u_sess-&gt;xact_cxt.ShmemVariableCache-&gt;latestCompletedXid, xid)));</span><br><span class="line">    LWLockRelease(XidGenLock); //解锁</span><br><span class="line">    return xid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h3><ul>
<li>单点提交：CommitTransaction(). 记录事务提交日志之后释放buffer、锁、磁盘文件等资源</li>
<li>提交日志实现：RecordTransactionCommit(),获取csn、写事务提交日志等xlog flush逻辑，不考虑多点逻辑</li>
</ul>
<img src="C:\Users\24738\Desktop\事务提交.png" alt="图片替换文本" width="1017" height="527" align="bottom"/>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/16/day3/" data-id="cl4i48rs60002nova6upp38qv" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/17/test/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          test
        
      </div>
    </a>
  
  
    <a href="/2022/06/14/day2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MogDB-server环境搭建</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/17/test/">test</a>
          </li>
        
          <li>
            <a href="/2022/06/16/day3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/14/day2/">MogDB-server环境搭建</a>
          </li>
        
          <li>
            <a href="/2022/06/13/day1/">First Blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Rookie Dai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>